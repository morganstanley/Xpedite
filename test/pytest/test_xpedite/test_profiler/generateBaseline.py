"""
Python module to clean up and generate files used with Xpedite pytests.
This module generates baseline profile information and probe state information.
Baseline information for profiles is created by generating a Jupyter notebook
for a new Xpedite run, and copying over the .xpd profile information file and
.data files from the xpedite run to the pytest data directory.

Author:  Brooke Elizabeth Cantwell, Morgan Stanley
"""

import os
import json
import cPickle as pickle
import argparse
from shutil                               import copy, rmtree
from xpedite.util                         import makeLogPath
from xpedite.transport.remote             import Remote
from xpedite.transport.net                import isIpLocal
from xpedite.benchmark                    import makeBenchmark
from test_xpedite.test_profiler.profile   import buildNotebook, loadProbes
from test_xpedite                         import (
                                            REPORT_CMD_BASELINE_PATH,
                                            BASELINE_CPU_INFO_PATH,
                                            PROBE_CMD_BASELINE_PATH, DATA_FILE_EXT,
                                            XPEDITE_APP_INFO_PATH, TXN_COUNT,
                                            THREAD_COUNT
                                          )
from test_xpedite.test_profiler.app       import TargetLauncher
from test_xpedite.test_profiler.profile   import generateProfiles
from test_xpedite.test_profiler.context   import Context
from test_xpedite.test_profiler.scenario  import ScenarioLoader

BENCHMARK_SCENARIO = 'benchmark'
BENCHMARK_APP_INFO_PATH = os.path.join(BENCHMARK_SCENARIO, 'appinfo.txt')
APPS = ['allocatorApp', 'dataTxnApp', 'multiThreadedApp', 'slowFixDecoderApp']
DATA_FILE_EXT_REGEX = r'*{}'.format(DATA_FILE_EXT)

class BaselineGenerator(object):
  """
  Set up and environment for loading scenarios in a remote or local environment
  """

  def __init__(self, runDir, hostname, context):
    self.remote = None
    self.runDir = runDir
    self.hostname = hostname
    self.context = context
    if not isIpLocal(hostname):
      self.remote = Remote(hostname, makeLogPath('remote'))
    self.scenarioLoader = ScenarioLoader()

  def __enter__(self):
    if self.remote:
      self.remote.__enter__()
    cleanUpDataDir(self.runDir)
    self.scenarioLoader.loadScenarios(self.runDir, APPS, remote=self.remote)
    return self


  def __exit__(self, excType, excVal, excTb):
    if self.remote:
      self.remote.__exit__(None, None, None)

def benchmarkProfile(context, scenario, runDir):
  """
  Create a benchmark for an application
  """
  with TargetLauncher(context, scenario) as app:
    if not os.path.isdir(os.path.join(runDir, scenario.appName, BENCHMARK_SCENARIO)):
      report = generateProfiles(app.xpediteApp, scenario)
      profiles = report.profiles 
      makeBenchmark(profiles, os.path.join(runDir, scenario.appName))
      benchmarkAppInfoPath = os.path.join(runDir, scenario.appName, BENCHMARK_APP_INFO_PATH)
      replaceWorkspace(benchmarkAppInfoPath, context.workspace, benchmarkAppInfoPath)

def replaceWorkspace(filePath, workspace, destination):
  """
  Trim the workspace path from file paths and rewrite to destination
  """
  with open(filePath, 'r') as fileHandle:
    appInfoStr = fileHandle.read()
  appInfoStr = appInfoStr.replace(workspace, '')
  with open(destination, 'w') as fileHandle:
    fileHandle.write(appInfoStr)

def cleanUpDataDir(runDir):
  """
  Old data files need to be removed before creating new files
  """
  import fnmatch
  for root, _, fileNames in os.walk(runDir):
    for fileName in fnmatch.filter(fileNames, DATA_FILE_EXT_REGEX):
      os.remove(os.path.join(root, fileName))

  for directory in os.listdir(runDir):
    if os.path.isdir(os.path.join(runDir, directory, BENCHMARK_SCENARIO)):
      rmtree(os.path.join(runDir, directory, BENCHMARK_SCENARIO))

def generateBaseline(context, scenario, runDir):
  """
  Generate the following files:
  1. .xpd data file generated from building a Jupyter notebook
     Used to test building of notebooks
  2. Xpedite application information file
     Used to attach profiler for testing recording, reporting, probe status, and notebooks
  3. xpediteDemo .data files
     Files that are collected by an xpedite app to build transactions
  4. Serialized probe baseline file
     Used to compare probe states generated by an xpedite app to baseline probes
  """
  with scenario as scenario:
    if BENCHMARK_SCENARIO not in scenario.name:
      benchmarkProfile(context, scenario, runDir)
    runDir = os.path.join(runDir, scenario.appName, scenario.name)
    _, dataFilePath, report, fullCpuInfo, dataFiles = buildNotebook(context, scenario)

    copy(dataFilePath, os.path.join(runDir, REPORT_CMD_BASELINE_PATH))

    for dataFile in dataFiles:
      copy(dataFile, os.path.join(runDir, os.path.basename(dataFile)))
    replaceWorkspace(
      report.app.appInfoPath, context.workspace, os.path.join(runDir, XPEDITE_APP_INFO_PATH)
    )

    baselineCpuInfoPath = os.path.join(runDir, BASELINE_CPU_INFO_PATH)
    with open(baselineCpuInfoPath, 'w') as fileHandle:
      json.dump(fullCpuInfo, fileHandle)

    baselineProbeMap = {}
    for probe in loadProbes(context, scenario):
      baselineProbeMap[probe.sysName] = probe
    with open(os.path.join(runDir, PROBE_CMD_BASELINE_PATH), 'wb') as probeFileHandle:
      probeFileHandle.write(pickle.dumps(baselineProbeMap))

def main():
  """
  Set the path to the data directory generated baseline files are stored in and
  generate files
  """
  defaultWorkspace = os.path.join(os.path.abspath(__file__).split('/test/')[0], '')
  parser = argparse.ArgumentParser()
  parser.add_argument('--rundir', help='temporary directory where files have been unzipped')
  parser.add_argument('--txncount', default=TXN_COUNT, help='number of transactions to generate')
  parser.add_argument('--threadcount', default=THREAD_COUNT, help='number of threads to use in application')
  parser.add_argument('--workspace', default=defaultWorkspace, help='prefix to trim off of file paths')
  parser.add_argument('--hostname', default='localhost', help='host to generate files on')
  args = parser.parse_args()

  context = Context(args.txncount, args.threadcount, args.workspace)
  with BaselineGenerator(args.rundir, args.hostname, context) as baselineGenerator:
    for scenario in baselineGenerator.scenarioLoader:
      generateBaseline(context, scenario, args.rundir)

if __name__ == '__main__':
  main()
